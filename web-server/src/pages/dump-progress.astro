---
export const prerender = false;

import Layout from "../layouts/Layout.astro";

import { IcRoundCheck } from "../components/ClientIcons/Icons";
import Collapsible from "../components/Collapsible.astro";
import LocaleDate from "../components/LocaleDate";
import DBSchedule from "../components/SPC/db/DBSchedule.astro";
import DBStatus from "../components/SPC/DumpProgress/DBStatus";
import FinishedTasks from "../components/SPC/DumpProgress/Task/FinishedTasks.astro";
import RunningTasks from "../components/SPC/DumpProgress/Task/RunningTasks.astro";
import Task, {
    type TaskType,
} from "../components/SPC/DumpProgress/Task/Task.astro";
import { TooltipButton } from "../components/TooltipButton";
import { redisClient } from "../db/redis";

let last_checked = await redisClient.get(
    "CELERY-WIKI_wiki-tasks:last_checked_for_tasks",
);
let last_checked_date = last_checked
    ? new Date(Number(last_checked) * 1000)
    : null;
let last_check_is_recent =
    last_checked_date != null &&
    new Date().getTime() - last_checked_date.getTime() < 24 * 60 * 60 * 1000; // 24 hours

let keys = await redisClient.hGetAll("CELERY-WIKI_wiki-tasks");
let tasks: TaskType[] = Object.entries(keys).map(([key, value]) => {
    let { name, status, startedAt, finishedAt, ...rest } = JSON.parse(value);
    return {
        name,
        status,
        startedAt: new Date(startedAt),
        finishedAt: finishedAt != null ? new Date(finishedAt) : undefined,
        ...rest,
    };
});


// const tasksStatusi = await redisClient.hGetAll("CELERY-WIKI_wiki-tasks-status");

const sortTasks = (a: TaskType, b: TaskType) => {
    // -1 comes first => running tasks first
    if (a.status === "RUNNING" && b.status !== "RUNNING") {
        return -1;
    }
    if (a.status !== "RUNNING" && b.status === "RUNNING") {
        return 1;
    }

    if (a.dumpDate !== b.dumpDate) {
        return a.dumpDate > b.dumpDate ? -1 : 1; // most recent first
    }

    if (!a.startedAt && !b.startedAt) return 0;
    if (!a.startedAt) return 1;
    if (!b.startedAt) return -1;
    return b.startedAt.getTime() - a.startedAt.getTime();
};

let numRunning = tasks.filter((t) => t.status == "RUNNING").length;

let numQueued = tasks.filter((t) => t.status == "QUEUED").length;

let queuedTasks = tasks.filter((t) => t.status == "QUEUED").sort(sortTasks);
let runningTasks = tasks.filter((t) => t.status == "RUNNING").sort(sortTasks);
let finishedTasks = tasks
    .filter((t) => t.status != "RUNNING" && t.status != "QUEUED")
    .sort(sortTasks);

let now = new Date();

type DB_STATUS_TYPE = "DONE" | "RUNNING" | "SCHEDULED" | "FAILED";
let dbStatus: DB_STATUS_TYPE;

// const isUpdatingRn = Object.entries(tasksStatusi)
//     .map(([_, v]) => v)
//     .some((v) => v === "RUNNING");
const isUpdatingRn = tasks.some((t) => t.status === "RUNNING");

if (isUpdatingRn) {
    dbStatus = "RUNNING";
} else {
    if (tasks.some((t) => t.status === "FAILED")) {
        dbStatus = "FAILED";
    } else {
        let lastTask = tasks
            .filter((t) => t.finishedAt != null)
            .sort(
                (t1, t2) => t1.finishedAt!.getTime() - t2.finishedAt!.getTime(),
            )[0];

        let ONE_DAY_MS = 24 * 60 * 60 * 1000;
        if (
            lastTask != null &&
            now.getTime() - lastTask.finishedAt!.getTime() <= ONE_DAY_MS
        ) {
            dbStatus = "DONE";
        } else {
            dbStatus = "SCHEDULED";
        }
    }
}

const timeFormat: Intl.DateTimeFormatOptions = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
    timeZoneName: "short",
    timeZone: "UTC", // by default show in UTC, client will convert to local time as long javascript is enabled
};
---

<Layout title="Dump progress">
    <main class="grid grid-cols-1 sm:grid-cols-10 gap-2">
        <div class="sm:col-span-6 lg:col-span-7">
            <div class="flex flex-wrap gap-1">
                <h1 class="text-3xl">Database Status</h1>
                <DBStatus dbStatus={dbStatus} />
            </div>
            <div class="mb-2 flex gap-1 items-center">
                <span class="text-secondary text-sm block">
                    Last checked: {
                        last_checked_date ? (
                            <LocaleDate
                                date={last_checked_date}
                                formatOption={timeFormat}
                                client:load
                            />
                        ) : (
                            "never"
                        )
                    }
                </span>
                {
                    last_check_is_recent && (
                        <TooltipButton tooltip="Last checked less than 24 hours ago">
                            <span class="text-green-500 dark:text-green-400 block w-4">
                                <IcRoundCheck />
                            </span>
                        </TooltipButton>
                    )
                }
            </div>

            <div class="text-secondary text-base mb-5">
                <p>
                    This pages tracks the progress of the background tasks that
                    fetch and process the <a
                        href="https://dumps.wikimedia.org/">
                        database dumps from Wikimedia.
                    </a>
                </p>

                <p>
                    New dumps are typically generated on the 1st and 20th of
                    each month. However, availability may be delayed by a day or
                    more depending on their size. The table to the right shows
                    when each wiki was last updated.
                </p>
            </div>

            <div class="flex gap-1 flex-wrap justify-between mb-1">
                <span>
                    {numQueued} Tasks Queued | {numRunning} Running | {
                        finishedTasks.length
                    }
                    Done
                </span>
            </div>
            {
                runningTasks.length == 0 && finishedTasks.length == 0 && (
                    <p class="text-secondary text-base">
                        No tasks have been run yet. You can check the
                        approximate database dump schedule on the right.
                    </p>
                )
            }

            <RunningTasks runningTasks={runningTasks} />
            {
                queuedTasks.length > 0 && (
                    <Collapsible>
                        <div slot="summary" class="w-full text-center">
                            {queuedTasks.length} Queued Tasks
                        </div>
                        <Task tasks={queuedTasks} className="flex" />
                    </Collapsible>
                )
            }
            <FinishedTasks finishedTasks={finishedTasks} />
        </div>

        <div class="sm:col-end-[-1] w-full sm:col-span-3 mt-5 sm:mt-0">
            <DBSchedule />
        </div>
    </main>
</Layout>
